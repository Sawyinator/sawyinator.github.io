<!DOCTYPE html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/favicons/marble-decider-favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <title>Marble Decider</title>
    
    <meta name="title" content="Marble Decider">
    <meta name="description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sawyinator.uk/projects/marble-decider">
    <meta property="og:title" content="Marble Decider">
    <meta property="og:description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <meta property="og:image" content="https://sawyinator.uk/assets/logos/marble-decider-logo.png">
    <meta name="theme-color" content="#64ff4e">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://sawyinator.uk/projects/marble-decider">
    <meta property="twitter:title" content="Marble Decider">
    <meta property="twitter:description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <meta property="twitter:image" content="https://sawyinator.uk/assets/logos/marble-decider-logo.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
    :root { 
        --bg: #010a01;          
        --ui: #052e16;          
        --acc: #64ff4e;         
        --gold: #fcd34d;        
        --glass: rgba(5, 46, 22, 0.85); 
        --danger: #ef4444;
    }

    body { 
        margin: 0; 
        overflow: hidden; 
        background: var(--bg); 
        font-family: 'Segoe UI', sans-serif; 
        color: #dcfce7; 
    }

    .back-home {
        position: fixed; top: 20px; left: 20px;
        text-decoration: none; color: var(--acc);
        font-weight: bold; background: var(--glass);
        padding: 10px 20px; border: 1px solid var(--acc);
        border-radius: 8px; transition: all 0.3s ease;
    }
    .back-home:hover { background: var(--acc); color: #052e16; }

    /* Module Browser Toggle */
    .module-browser-btn {
        position: fixed; top: 20px; right: 20px;
        background: var(--ui); color: var(--acc);
        border: 1px solid var(--acc); padding: 10px 20px;
        border-radius: 8px; cursor: pointer; font-weight: bold; z-index: 550;
    }

    #lobby {
        position: fixed; inset: 0; z-index: 500;
        background: radial-gradient(circle at center, #052e16 0%, #010a01 100%);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .lobby-box {
        background: var(--ui); padding: 40px; border: 1px solid var(--acc);
        border-radius: 20px; width: 400px; text-align: center;
    }
    textarea {
        width: 100%; height: 200px; background: #010a01; color: var(--acc);
        border: 1px solid #14532d; border-radius: 8px; padding: 10px; margin-bottom: 20px;
    }
    .start-btn {
        background: var(--acc); color: #052e16; border: none; padding: 15px 40px;
        font-size: 1.2rem; font-weight: 900; border-radius: 50px; cursor: pointer;
    }

    /* MODULE BROWSER UI */
    #module-overlay {
        position: fixed; inset: 0; z-index: 1000;
        background: var(--bg); display: none;
        flex-direction: column; padding: 40px; overflow-y: auto;
    }
    .module-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px; margin-top: 20px;
    }
    .module-card {
        background: var(--ui); border: 1px solid #14532d; padding: 15px; border-radius: 12px;
        display: flex; flex-direction: column; gap: 10px;
    }
    .module-card.enabled { border-color: var(--acc); box-shadow: 0 0 10px rgba(100, 255, 78, 0.2); }
    .module-card h3 { margin: 0; color: var(--acc); font-size: 1rem; }
    .module-actions { display: flex; gap: 5px; margin-top: auto; }
    .mod-btn { flex: 1; padding: 5px; border-radius: 4px; border: none; cursor: pointer; font-size: 0.8rem; font-weight: bold; }
    .mod-toggle { background: #14532d; color: white; }
    .mod-toggle.on { background: var(--acc); color: #052e16; }
    .mod-edit { background: var(--gold); }
    .mod-del { background: var(--danger); color: white; }

    /* CODE EDITOR */
    #editor-modal {
        position: fixed; inset: 0; z-index: 1100; background: rgba(0,0,0,0.9);
        display: none; align-items: center; justify-content: center;
    }
    .editor-box {
        background: var(--ui); width: 90%; max-width: 800px; padding: 20px; border-radius: 15px;
    }
    #moduleCodeInput {
        width: 100%; height: 300px; font-family: monospace; background: #000; color: #64ff4e; margin-top: 10px;
    }

    #leaderboard {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: var(--glass); padding: 15px; border: 1px solid var(--acc);
        border-radius: 12px; min-width: 280px; max-height: 80vh; overflow-y: auto; 
        backdrop-filter: blur(8px); display: none;
    }
    .leader-row { display: grid; grid-template-columns: 1fr 80px; gap: 10px; margin-bottom: 8px; font-size: 0.85rem; font-weight: bold; }
    .finished-row { border-left: 3px solid var(--gold); background: rgba(252, 211, 77, 0.1); padding-left: 5px; color: var(--gold); }
    .header-row { font-size: 0.65rem; color: #4ade80; border-bottom: 1px solid #14532d; }
    
    #results-modal, #confirm-modal {
        position: fixed; inset: 0; z-index: 600; background: rgba(1, 10, 1, 0.9);
        display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .results-box, .confirm-box {
        background: var(--ui); border: 2px solid var(--gold); border-radius: 20px;
        width: 100%; max-width: 500px; max-height: 85vh; overflow-y: auto; padding: 30px;
        box-shadow: 0 0 20px rgba(252, 211, 77, 0.2);
    }
    .confirm-box { border-color: var(--danger); text-align: center; }
    .results-item { padding: 10px; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; font-weight: bold; color: var(--gold); }

    #controls { position: fixed; bottom: 20px; right: 20px; z-index: 100; display: none; gap: 10px; }
    .ui-btn { border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
    .reset-btn { background: #ef4444; }
    .toggle-btn { background: #14532d; border: 1px solid var(--acc); color: var(--acc); }
    .results-btn { background: var(--gold); color: #020617; display: none; }
    .remove-victor-btn { background: transparent; border: 2px solid var(--danger); color: var(--danger); display: none; }
    
    #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 200; pointer-events: none; display: none; }
    #countdown { font-size: 15rem; font-weight: 900; color: var(--acc); text-shadow: 0 0 20px rgba(100, 255, 78, 0.5); }
</style>
</head>
<body>

<div id="lobby">
    <a href="/" class="back-home">‚Üê Back to main website</a>
    <button class="module-browser-btn" onclick="openModuleBrowser()">MODULE BROWSER</button>
    <div class="lobby-box">
        <h1 style="color:var(--acc)">MARBLE DECIDER</h1>
        <textarea id="nameInput" placeholder="Enter Names">Alpha&#10;Beta&#10;Gamma&#10;Delta&#10;Epsilon&#10;Zeta&#10;Eta&#10;Theta&#10;Iota&#10;Kappa</textarea>
        <div style="display: flex; gap: 10px; flex-direction: column;">
            <button class="start-btn" id="startBtn">START RACE</button>
            <button class="ui-btn toggle-btn" id="shuffleBtn" style="padding: 12px; border-radius: 50px;">SHUFFLE NAMES</button>
        </div>
    </div>
</div>

<div id="module-overlay">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h1 style="color: var(--acc); margin: 0;">MODULE BROWSER</h1>
        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: flex-end;">
            <a href="creator/" class="ui-btn creator-link-btn">MODULE CREATOR</a>
            
            <button class="ui-btn toggle-btn" onclick="addCustomModule()">+ NEW CUSTOM MODULE</button>
            <button class="ui-btn toggle-btn" onclick="importModules()">IMPORT JSON</button>
            <button class="ui-btn toggle-btn" onclick="exportModules()">EXPORT JSON</button>
            <button class="ui-btn reset-btn" onclick="closeModuleBrowser()">CLOSE</button>
        </div>
    </div>
    <p>Select at least 2 modules to be used in the race generation.</p>
    <div class="module-grid" id="module-grid"></div>
</div>

<div id="editor-modal">
    <div class="editor-box">
        <h2 id="editor-title" style="color: var(--acc);">Edit Module</h2>
        <input type="text" id="moduleNameInput" placeholder="Module Name" style="width: 100%; padding: 10px; background: #000; color: var(--acc); border: 1px solid #14532d; border-radius: 8px; box-sizing: border-box;">
        
        <textarea id="moduleCodeInput" placeholder="Add custom module code here"></textarea>
        <div style="display: flex; gap: 10px; margin-top: 15px;">
            <button class="ui-btn toggle-btn" style="flex: 1;" onclick="saveModule()">SAVE</button>
            <button class="ui-btn reset-btn" style="flex: 1;" onclick="document.getElementById('editor-modal').style.display='none'">CANCEL</button>
        </div>
    </div>
</div>

<div id="results-modal">
    <div class="results-box">
        <h2 style="color:var(--gold); text-align:center; margin-top:0;">üèÜ FINAL STANDINGS üèÜ</h2>
        <div id="full-results-list"></div>
        <button class="start-btn" style="width:100%; margin-top:20px;" id="closeResults">CLOSE</button>
    </div>
</div>

<div id="confirm-modal">
    <div class="confirm-box">
        <h2 style="color:var(--danger); margin-top:0;">REMOVE VICTOR?</h2>
        <p>This will remove <span id="victorNameDisplay" style="font-weight: 900;"></span> and restart the race immediately.</p>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="ui-btn reset-btn" style="flex: 1;" id="confirmRemove">REMOVE & RESTART</button>
            <button class="ui-btn toggle-btn" style="flex: 1;" id="cancelRemove">CANCEL</button>
        </div>
    </div>
</div>

<div id="overlay"><div id="countdown">3</div></div>
<div id="leaderboard">
    <div class="leader-row header-row"><span>Racer</span></div>
    <div id="leader-list"></div>
    <div id="recent-victors-container" style="display: none; margin-top: 20px; border-top: 1px solid var(--acc); padding-top: 10px;">
        <div class="leader-row header-row"><span>Recent Victors</span><span style="text-align:right">Time</span></div>
        <div id="recent-victors-list"></div>
    </div>
</div>

<div id="controls">
    <button class="ui-btn remove-victor-btn" id="removeVictorBtn">REMOVE VICTOR</button>
    <button class="ui-btn results-btn" id="resBtn">FULL RESULTS</button>
    <button class="ui-btn toggle-btn" id="toggleBoard">HIDE/SHOW LEADERBOARDS</button>
    <button class="ui-btn reset-btn" id="reloadBtn">BACK TO LOBBY</button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

let engine, render, runner, animationFrameId;
let marbles = [], finishedMarbles = [], finishLineY = 0;
let camY = 0, autoResultsShown = false, startTime = null, winnerName = null;

const createGuides = (world, y, cx) => {
    const wallStyle = { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 2 } };
    Composite.add(world, [
        Bodies.rectangle(cx - 350, y + 100, 300, 60, { ...wallStyle, angle: 0.5 }),
        Bodies.rectangle(cx + 350, y + 100, 300, 60, { ...wallStyle, angle: -0.5 })
    ]);
};

// --- BUILT-IN MODULES ---
const DefaultModules = [
    {
        name: "tri-blade spinner",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            const parts = [];
            for(let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                parts.push(Bodies.rectangle(cx + Math.cos(angle) * 120, y + 500 + Math.sin(angle) * 120, 320, 80, { 
                    angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } 
                }));
            }
            const spinner = Body.create({ parts: parts, isStatic: false, frictionAir: 0 });
            const constraint = Constraint.create({ pointA: { x: cx, y: y + 500 }, bodyB: spinner, stiffness: 1, length: 0 });
            Composite.add(world, [spinner, constraint]);
            Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(spinner, 0.05));
        }
    },
    {
         name: "moving diamond splitter",
         create: (world, y, cx) => {
         const wallStyle = { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
         const splitter = Bodies.polygon(cx, y + 450, 4, 180, { ...wallStyle, angle: Math.PI / 4 });
         Composite.add(world, splitter);
         Events.on(engine, 'beforeUpdate', (event) => {
            const time = event.timestamp;
            const newX = cx + Math.sin(time * 0.002) * 200;
            Body.setPosition(splitter, { x: newX, y: y + 450 });
         });
        [cx - 300, cx + 300].forEach((xPos, i) => {
            const gate = Bodies.rectangle(xPos, y + 750, 240, 70, { render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 15 }, frictionAir: 0 });
                 const cons = Constraint.create({ pointA: { x: xPos, y: y + 750 }, bodyB: gate, stiffness: 1, length: 0 });
                 Composite.add(world, [gate, cons]);
                 Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(gate, i === 0 ? 0.08 : -0.08));
            });
        }
    },
    {
        name: "dual spinners",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            [cx - 240, cx + 240].forEach((xPos, i) => {
                const sat = Bodies.rectangle(xPos + (i === 0 ? 100 : -100), y + 500, 280, 80, { render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 20 }, frictionAir: 0 });
                const cons = Constraint.create({ pointA: { x: xPos, y: y + 500 }, bodyB: sat, stiffness: 1, length: 0 });
                Composite.add(world, [sat, cons]);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(sat, i === 0 ? 0.18 : -0.18));
            });
        }
    },
    {
        name: "hanging rectangles",
        create: (world, y, cx) => {
            for(let i = 0; i < 2; i++) {
                const xPos = cx - 200 + (i * 400);
                const weight = Bodies.rectangle(xPos, y + 600, 300, 100, { render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 30 }, frictionAir: 0.02, restitution: 0.7, inertia: 7500 });
                const pivot = Constraint.create({ pointA: { x: xPos, y: y + 150 }, bodyB: weight, stiffness: 0.01, length: 400, render: { strokeStyle: '#64ff4e', lineWidth: 4 } });
                Composite.add(world, [weight, pivot]);
            }
        }
    },
    {
        name: "grinder",
        create: (world, y, cx) => {
            [cx - 180, cx + 180].forEach((xPos, idx) => {
                const parts = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    if (i === 0) continue; 
                    parts.push(Bodies.rectangle(xPos + Math.cos(angle) * 140, y + 450 + Math.sin(angle) * 140, 100, 45, { angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 3 } }));
                }
                const spinner = Body.create({ parts: parts, isStatic: false, frictionAir: 0 });
                const constraint = Constraint.create({ pointA: { x: xPos, y: y + 450 }, bodyB: spinner, stiffness: 1, length: 0 });
                Composite.add(world, [spinner, constraint]);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(spinner, idx === 0 ? 0.1 : -0.1));
            });
        }
    },
    {
        name: "zigzags",
        create: (world, y, cx) => {
            const stepStyle = { isStatic: true, chamfer: { radius: 40 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 5 } };
            for (let i = 0; i < 5; i++) {
                const isLeft = i % 2 === 0;
                Composite.add(world, Bodies.rectangle(isLeft ? cx - 350 : cx + 350, y + (i * 180), 750, 100, { ...stepStyle, angle: isLeft ? 0.5 : -0.5 }));
            }
        }
    },
    {
        name: "funnel",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, chamfer: { radius: 30 }, restitution: 0.2, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 8 } };
            Composite.add(world, [
                Bodies.rectangle(cx - 320, y + 250, 550, 110, { ...wallStyle, angle: 0.75 }),
                Bodies.rectangle(cx + 320, y + 250, 550, 110, { ...wallStyle, angle: -0.75 }),
                Bodies.circle(cx, y + 550, 80, { isStatic: true, restitution: 0.3, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } })
            ]);
        }
    },
    {
        name: "plinko",
        create: (world, y, cx) => {
            const bumperStyle = { isStatic: true, restitution: 1.1, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
            const positions = [{x: -160, y: 150}, {x: 160, y: 150}, {x: 0, y: 400}, {x: -160, y: 650}, {x: 160, y: 650}];
            positions.forEach(pos => {
                Composite.add(world, Bodies.circle(cx + pos.x, y + pos.y, 55, bumperStyle));
            });
        }
    },
    {
    name: "50 50",
    create: (world, y, cx) => {
        const wallStyle = { isStatic: true, chamfer: { radius: 15 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
        const zigzagStyle = { isStatic: true, chamfer: { radius: 10 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
        Composite.add(world, [
            Bodies.rectangle(cx - 280, y + 120, 500, 60, { ...wallStyle, angle: 0.4 }),
            Bodies.rectangle(cx + 280, y + 120, 500, 60, { ...wallStyle, angle: -0.4 })
        ]);
        const divider = Bodies.polygon(cx, y + 260, 3, 60, { isStatic: true, angle: Math.PI / 2, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } });
        Composite.add(world, divider);
        Events.on(engine, 'beforeUpdate', (event) => {
            const time = event.timestamp;
            const newX = cx + Math.sin(time * 0.003) * 70;
            Body.setPosition(divider, { x: newX, y: y + 260 });
        });
        const dividerHeight = 630;
        Composite.add(world, Bodies.rectangle(cx, y + 590, 60, dividerHeight, wallStyle));
        const rampWidth = 340; 
        for (let i = 0; i < 4; i++) {
            const rollsRight = (i % 2 === 1); 
            const py = y + 400 + (i * 110);
            const xOffset = rollsRight ? -250 : -170;
            Composite.add(world, Bodies.rectangle(cx + xOffset, py, rampWidth, 30, { ...zigzagStyle, angle: rollsRight ? 0.15 : -0.15 }));
        }
    }
}
];

// --- MODULE SYSTEM LOGIC ---
let customModules = [];
let enabledModules = []; // List of names
let editingIndex = -1;

function loadModuleData() {
    const savedCustom = localStorage.getItem('marbleCustomModules');
    if (savedCustom) customModules = JSON.parse(savedCustom);
    
    const savedEnabled = localStorage.getItem('marbleEnabledModules');
    if (savedEnabled) {
        enabledModules = JSON.parse(savedEnabled);
    } else {
        // Default to all built-ins enabled
        enabledModules = DefaultModules.map(m => m.name);
    }
}

function saveModuleData() {
    localStorage.setItem('marbleCustomModules', JSON.stringify(customModules));
    localStorage.setItem('marbleEnabledModules', JSON.stringify(enabledModules));
}

function openModuleBrowser() {
    document.getElementById('module-overlay').style.display = 'flex';
    renderModuleGrid();
}

function closeModuleBrowser() {
    if (enabledModules.length < 2) {
        alert("Please enable at least 2 modules!");
        return;
    }
    document.getElementById('module-overlay').style.display = 'none';
}

function renderModuleGrid() {
    const grid = document.getElementById('module-grid');
    grid.innerHTML = '';

    // 1. Render Built-in Modules
    DefaultModules.forEach(m => {
        const isEnabled = enabledModules.includes(m.name);
        const card = document.createElement('div');
        card.className = `module-card ${isEnabled ? 'enabled' : ''}`;
        card.innerHTML = `
            <h3>${m.name} <small>(Built-in)</small></h3>
            <div class="module-actions">
                <button class="mod-btn mod-toggle ${isEnabled ? 'on' : ''}" onclick="toggleModule('${m.name}')">
                    ${isEnabled ? 'ENABLED' : 'DISABLED'}
                </button>
            </div>
        `;
        grid.appendChild(card);
    });

    // 2. Render Custom Modules
    customModules.forEach((m, idx) => {
        const currentName = getNameFromCode(m.code);
        const isEnabled = enabledModules.includes(currentName);
        
        const card = document.createElement('div');
        card.className = `module-card ${isEnabled ? 'enabled' : ''}`;
        card.innerHTML = `
            <h3>${currentName}</h3>
            <div class="module-actions">
                <button class="mod-btn mod-toggle ${isEnabled ? 'on' : ''}" onclick="toggleModule('${currentName}')">
                    ${isEnabled ? 'ENABLED' : 'DISABLED'}
                </button>
                <button class="mod-btn mod-edit" style="background:#3b82f6; color:white;" onclick="renameModule(${idx})">RENAME</button>
                <button class="mod-btn mod-edit" onclick="editCustomModule(${idx})">EDIT CODE</button>
                <button class="mod-btn mod-del" onclick="deleteCustomModule(${idx})">DEL</button>
            </div>
        `;
        grid.appendChild(card);
    });
} // This is the ONLY closing brace needed for the whole function

function toggleModule(name) {
    if (enabledModules.includes(name)) {
        if (enabledModules.length <= 2) {
            alert("Minimum 2 modules required!");
            return;
        }
        enabledModules = enabledModules.filter(n => n !== name);
    } else {
        enabledModules.push(name);
    }
    saveModuleData();
    renderModuleGrid();
}

function addCustomModule() {
    editingIndex = -1;
    document.getElementById('editor-title').innerText = "New Custom Module";
    
    // This clears the Name input field entirely
    document.getElementById('moduleNameInput').value = "";
    
    // This clears the Code textarea entirely
    document.getElementById('moduleCodeInput').value = "";
    
    document.getElementById('editor-modal').style.display = 'flex';
}

function editCustomModule(idx) {
    editingIndex = idx;
    const m = customModules[idx];
    document.getElementById('editor-title').innerText = "Edit Module";
    document.getElementById('moduleNameInput').value = m.name;
    document.getElementById('moduleCodeInput').value = m.code;
    document.getElementById('editor-modal').style.display = 'flex';
}

function saveModule() {
    const name = document.getElementById('moduleNameInput').value.trim();
    const code = document.getElementById('moduleCodeInput').value.trim();
    
    // Basic check to prevent saving empty modules
    if (!name || !code) {
        alert("Please enter both a name and some code!");
        return;
    }

    if (editingIndex === -1) {
        customModules.push({ name, code });
        enabledModules.push(name);
    } else {
        const oldName = customModules[editingIndex].name;
        enabledModules = enabledModules.map(n => n === oldName ? name : n);
        customModules[editingIndex] = { name, code };
    }
    
    saveModuleData();
    document.getElementById('editor-modal').style.display = 'none';
    renderModuleGrid();
}

function deleteCustomModule(idx) {
    const name = customModules[idx].name;
    enabledModules = enabledModules.filter(n => n !== name);
    customModules.splice(idx, 1);
    saveModuleData();
    renderModuleGrid();
}

function exportModules() {
    const data = JSON.stringify({ custom: customModules, enabled: enabledModules });
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'marble_modules.json';
    a.click();
}

function importModules() {
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = event => {
            const data = JSON.parse(event.target.result);
            customModules = data.custom || [];
            enabledModules = data.enabled || [];
            saveModuleData();
            renderModuleGrid();
        };
        reader.readAsText(file);
    };
    input.click();
}

// Helper to turn strings into executable functions safely-ish
function getModuleLogic(m) {
    if (m.create) return m.create; 
    try {
        // Extract the function body from the string "create: (world, y, cx) => { ... }"
        const codeClean = m.code.substring(m.code.indexOf('=>') + 2).trim();
        const body = codeClean.startsWith('{') ? codeClean.slice(1, -1) : codeClean;
        return new Function('world', 'y', 'cx', body);
    } catch (e) {
        console.error("Failed to parse module: " + m.name, e);
        return () => {}; 
    }
}

window.onload = function() {
    loadModuleData();
    const nameBox = document.getElementById('nameInput');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');

    const saved = localStorage.getItem('marbleRacerNames');
    if (saved) nameBox.value = saved;

    shuffleBtn.onclick = function() {
        const lines = nameBox.value.split('\n').filter(n => n.trim() !== "");
        for (let i = lines.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lines[i], lines[j]] = [lines[j], lines[i]];
        }
        nameBox.value = lines.join('\n');
    };

    startBtn.onclick = function() {
        const names = nameBox.value.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
            localStorage.setItem('marbleRacerNames', nameBox.value);
            initiateRace(names);
        }
    };

    document.getElementById('reloadBtn').onclick = () => location.reload();
    document.getElementById('toggleBoard').onclick = toggleLeaderboard;
    document.getElementById('closeResults').onclick = () => document.getElementById('results-modal').style.display='none';
    document.getElementById('resBtn').onclick = showFullResults;

    document.getElementById('removeVictorBtn').onclick = () => {
        document.getElementById('victorNameDisplay').innerText = winnerName;
        document.getElementById('confirm-modal').style.display = 'flex';
    };

    document.getElementById('cancelRemove').onclick = () => document.getElementById('confirm-modal').style.display = 'none';

    document.getElementById('confirmRemove').onclick = () => {
        let currentNames = nameBox.value.split('\n').map(n => n.trim()).filter(n => n !== "" && n !== winnerName);
        for (let i = currentNames.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [currentNames[i], currentNames[j]] = [currentNames[j], currentNames[i]];
        }
        nameBox.value = currentNames.join('\n');
        localStorage.setItem('marbleRacerNames', nameBox.value);
        document.getElementById('confirm-modal').style.display = 'none';
        cleanupWorld();
        initiateRace(currentNames);
    };
};

function cleanupWorld() {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (render) {
        Render.stop(render);
        render.canvas.remove();
        render.canvas = null;
        render.context = null;
    }
    if (engine) Engine.clear(engine);
    marbles = [];
    finishedMarbles = [];
    autoResultsShown = false;
    winnerName = null;
    camY = 0;
    document.getElementById('resBtn').style.display = 'none';
    document.getElementById('removeVictorBtn').style.display = 'none';
    document.getElementById('recent-victors-container').style.display = 'none';
    document.getElementById('results-modal').style.display = 'none';
}

function initiateRace(names) {
    document.getElementById('lobby').style.display = 'none';
    document.getElementById('leaderboard').style.display = 'block';
    document.getElementById('controls').style.display = 'flex';
    setupRace(names);
}

function setupRace(names) {
    engine = Engine.create({ positionIterations: 10, velocityIterations: 10 }); 
    render = Render.create({
        element: document.body, engine: engine,
        options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#010a01' }
    });

    const cx = window.innerWidth / 2;
    const SEG_HEIGHT = 900;
    const trackDepth = 12; 
    let currentY = 400;
    let lastModuleName = "";

    // FILTER ENABLED MODULES
    const pool = [
        ...DefaultModules.filter(m => enabledModules.includes(m.name)),
        ...customModules.filter(m => enabledModules.includes(m.name))
    ];

    for(let i = 0; i < trackDepth; i++) {
        let selected;
        do { selected = pool[Math.floor(Math.random() * pool.length)]; } while (selected.name === lastModuleName && pool.length > 1);
        lastModuleName = selected.name;
        
        const logic = getModuleLogic(selected);
        logic(engine.world, currentY, cx);
        currentY += SEG_HEIGHT;
    }

    finishLineY = currentY + 400;
    const wallWidth = 2000;
    const wallStyle = { isStatic: true, friction: 0.1, restitution: 0.3, render: { fillStyle: '#010a01', strokeStyle: '#14532d', lineWidth: 1 } };
    
    Composite.add(engine.world, [
        Bodies.rectangle(cx - 410 - (wallWidth/2), currentY/2 + 2500, wallWidth, currentY + 10000, wallStyle),
        Bodies.rectangle(cx + 410 + (wallWidth/2), currentY/2 + 2500, wallWidth, currentY + 10000, wallStyle)
    ]);

    const checkerCanvas = document.createElement('canvas');
    const checkerCtx = checkerCanvas.getContext('2d');
    checkerCanvas.width = 40; checkerCanvas.height = 40;
    checkerCtx.fillStyle = '#052e16'; checkerCtx.fillRect(0, 0, 40, 40);
    checkerCtx.fillStyle = '#64ff4e'; checkerCtx.fillRect(0, 0, 20, 20); checkerCtx.fillRect(20, 20, 20, 20);
    const finishPattern = checkerCtx.createPattern(checkerCanvas, 'repeat');

    Composite.add(engine.world, [
        Bodies.rectangle(cx, finishLineY, 820, 120, { isStatic: true, isSensor: true, label: 'finish', render: { fillStyle: finishPattern, strokeStyle: '#64ff4e', lineWidth: 6 } })
    ]);

    const gate = Bodies.rectangle(cx, 180, 800, 80, { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 5 } });
    Composite.add(engine.world, gate);

    const marbleRadius = 20, padding = 4, cellSize = (marbleRadius * 2) + padding, gateWidth = 780, marblesPerRow = Math.floor(gateWidth / cellSize);

    marbles = names.map((n, i) => {
        const color = `hsl(${i * (360/names.length)}, 70%, 55%)`;
        const row = Math.floor(i / marblesPerRow), col = i % marblesPerRow;
        const marblesInThisRow = Math.min(marblesPerRow, names.length - (row * marblesPerRow));
        const rowWidth = (marblesInThisRow - 1) * cellSize;
        const startX = cx - (rowWidth / 2) + (col * cellSize), startY = 150 - (row * cellSize); 
        return Bodies.circle(startX, startY, marbleRadius, { restitution: 0.4, friction: 0, frictionAir: 0.005, label: n, render: { fillStyle: color, textColor: color }, isFinished: false, finishTime: null });
    });
    Composite.add(engine.world, marbles);

    Events.on(engine, 'afterUpdate', () => {
        const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
        let liveHtml = '';
        active.slice(0, 10).forEach((m, i) => {
            let gapDisplay = '-';
            const marbleBehind = active[i + 1];
            if (marbleBehind) gapDisplay = `+${((m.position.y - marbleBehind.position.y) / 50).toFixed(1)}m`;
            liveHtml += `<div class="leader-row" style="color:${m.render.textColor}"><span>${finishedMarbles.length + i + 1}. ${m.label}</span><span style="text-align:right">${gapDisplay}</span></div>`;
        });
        document.getElementById('leader-list').innerHTML = liveHtml;

        if (finishedMarbles.length > 0) {
            document.getElementById('recent-victors-container').style.display = 'block';
            const recent = [...finishedMarbles].reverse().slice(0, 10);
            let victorsHtml = '';
            recent.forEach((m) => {
                const rank = finishedMarbles.indexOf(m) + 1;
                victorsHtml += `<div class="leader-row finished-row" style="color:${m.render.textColor}; font-size: 0.75rem;"><span>#${rank} ${m.label}</span><span style="text-align:right">${m.finishTime}s</span></div>`;
            });
            document.getElementById('recent-victors-list').innerHTML = victorsHtml;
        }

        if (active.length === 0 && !autoResultsShown && marbles.length > 0) { 
            autoResultsShown = true; showFullResults(); 
        }
    });

    Events.on(engine, 'collisionStart', (e) => {
        e.pairs.forEach(p => {
            const marble = p.bodyA.label === 'finish' ? p.bodyB : (p.bodyB.label === 'finish' ? p.bodyA : null);
            if (marble && !marble.isFinished && marble.label && !marble.label.includes('Body')) {
                marble.isFinished = true;
                marble.finishTime = ((performance.now() - startTime) / 1000).toFixed(2);
                finishedMarbles.push(marble);
                document.getElementById('resBtn').style.display = 'block';
                document.getElementById('removeVictorBtn').style.display = 'block';
                if (finishedMarbles.length === 1) {
                    winnerName = marble.label;
                    confetti({ particleCount: 150, origin: { y: 0.6 } });
                }
            }
        });
    });

    const overlay = document.getElementById('overlay'), countDisplay = document.getElementById('countdown');
    overlay.style.display = 'flex';
    let count = 3; countDisplay.innerText = count;
    const timer = setInterval(() => {
        count--;
        if(count <= 0) { clearInterval(timer); overlay.style.display = 'none'; Composite.remove(engine.world, gate); startTime = performance.now(); }
        else { countDisplay.innerText = count; }
    }, 1000);

    let lastTime = 0;
    function update(time) {
        if (time - lastTime >= (1000/60)) {
            Engine.update(engine, 1000/60);
            const followTargets = marbles.filter(m => !m.isFinished);
            if (followTargets.length > 0) {
                const leadY = Math.max(...followTargets.map(m => m.position.y));
                camY += (leadY - camY - (window.innerHeight / 3)) * 0.1; 
            }
            Render.lookAt(render, { min: { x: cx - window.innerWidth/2, y: camY }, max: { x: cx + window.innerWidth/2, y: camY + window.innerHeight } });
            Render.world(render);
            const ctx = render.context;
            ctx.font = 'bold 20px "Segoe UI"'; ctx.textAlign = 'center';
            const minY = render.bounds.min.y - 50, maxY = render.bounds.max.y + 50;
            marbles.forEach(m => {
                if(!m.isFinished && m.position.y > minY && m.position.y < maxY) {
                    const x = m.position.x - render.bounds.min.x, y = m.position.y - render.bounds.min.y;
                    ctx.fillStyle = m.render.textColor; ctx.fillText(m.label, x, y - 25);
                }
            });
            lastTime = time;
        }
        animationFrameId = requestAnimationFrame(update);
    }
    animationFrameId = requestAnimationFrame(update);
}

function toggleLeaderboard() {
    const lb = document.getElementById('leaderboard');
    lb.style.display = lb.style.display === 'none' ? 'block' : 'none';
}

function showFullResults() {
    const list = document.getElementById('full-results-list');
    const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
    const allRanked = [...finishedMarbles, ...active];
    list.innerHTML = allRanked.map((m, i) => `
        <div class="results-item" style="color:${m.render.textColor}"><span>#${i+1} ${m.label}</span><span>${m.isFinished ? m.finishTime + 's' : 'DNF'}</span></div>
    `).join('');
    document.getElementById('results-modal').style.display = 'flex';
}
// Extracts the name from the code string
function getNameFromCode(code) {
    const match = code.match(/name:\s*["'`](.*?)["'`]/);
    return match ? match[1] : "Unnamed Module";
}

// Replaces the name in the code string with a new one
function updateNameInCode(code, newName) {
    return code.replace(/(name:\s*["'`](.*?)(["'`],?))/, `name: "${newName}"$3`);
}
function renameModule(idx) {
    const oldCode = customModules[idx].code;
    const oldName = getNameFromCode(oldCode);
    const newName = prompt("Enter new name for the module:", oldName);
    
    if (newName && newName !== oldName) {
        // Update the code string
        const newCode = updateNameInCode(oldCode, newName);
        customModules[idx].code = newCode;
        
        // Update the enabled list so it doesn't get "unselected"
        enabledModules = enabledModules.map(n => n === oldName ? newName : n);
        
        saveModuleData();
        renderModuleGrid();
    }
}
</script>
</body>
</html>
