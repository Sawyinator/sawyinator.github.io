<!DOCTYPE html>
<html lang="en">
<link rel="icon" type="image/png" href="/assets/favicons/marble-decider-favicon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <title>Marble Decider</title>
    
    <!-- Embed Behaviours -->
    
    <meta name="title" content="Marble Decider">
    <meta name="description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sawyinator.uk/projects/marble-decider">
    <meta property="og:title" content="Marble Decider">
    <meta property="og:description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <meta property="og:image" content="https://sawyinator.uk/assets/logos/marble-decider-logo.png">
    <meta name="theme-color" content="#64ff4e">

    <!-- Twitter Embed Behaviours -->
    
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://sawyinator.uk/projects/marble-decider">
    <meta property="twitter:title" content="Marble Decider">
    <meta property="twitter:description" content="Bascially just the wheel of names with a fancy way of deciding. Thought it was a fun idea.">
    <meta property="twitter:image" content="https://sawyinator.uk/assets/logos/marble-decider-logo.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    
    <style>
    :root { 
        --bg: #010a01;          
        --ui: #052e16;          
        --acc: #64ff4e;         
        --gold: #fcd34d;        
        --glass: rgba(5, 46, 22, 0.85); 
    }

    body { 
        margin: 0; 
        overflow: hidden; 
        background: var(--bg); 
        font-family: 'Segoe UI', sans-serif; 
        color: #dcfce7; 
    }

    .back-home {
        position: fixed; top: 20px; left: 20px;
        text-decoration: none; color: var(--acc);
        font-weight: bold; background: var(--glass);
        padding: 10px 20px; border: 1px solid var(--acc);
        border-radius: 8px; transition: all 0.3s ease;
    }
    .back-home:hover { background: var(--acc); color: #052e16; }

    #lobby {
        position: fixed; inset: 0; z-index: 500;
        background: radial-gradient(circle at center, #052e16 0%, #010a01 100%);
        display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .lobby-box {
        background: var(--ui); padding: 40px; border: 1px solid var(--acc);
        border-radius: 20px; width: 400px; text-align: center;
    }
    textarea {
        width: 100%; height: 200px; background: #010a01; color: var(--acc);
        border: 1px solid #14532d; border-radius: 8px; padding: 10px; margin-bottom: 20px;
    }
    .start-btn {
        background: var(--acc); color: #052e16; border: none; padding: 15px 40px;
        font-size: 1.2rem; font-weight: 900; border-radius: 50px; cursor: pointer;
    }

    #leaderboard {
        position: fixed; top: 20px; right: 20px; z-index: 100;
        background: var(--glass); padding: 15px; border: 1px solid var(--acc);
        border-radius: 12px; min-width: 280px; max-height: 80vh; overflow-y: auto; 
        backdrop-filter: blur(8px); display: none;
    }
    .leader-row { display: grid; grid-template-columns: 1fr 80px; gap: 10px; margin-bottom: 8px; font-size: 0.85rem; font-weight: bold; }
    .finished-row { border-left: 3px solid var(--gold); background: rgba(252, 211, 77, 0.1); padding-left: 5px; color: var(--gold); }
    .header-row { font-size: 0.65rem; color: #4ade80; border-bottom: 1px solid #14532d; }
    
    #results-modal {
        position: fixed; inset: 0; z-index: 600; background: rgba(1, 10, 1, 0.9);
        display: none; align-items: center; justify-content: center; padding: 20px;
    }
    .results-box {
        background: var(--ui); border: 2px solid var(--gold); border-radius: 20px;
        width: 100%; max-width: 500px; max-height: 85vh; overflow-y: auto; padding: 30px;
        box-shadow: 0 0 20px rgba(252, 211, 77, 0.2);
    }
    .results-item { padding: 10px; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; font-weight: bold; color: var(--gold); }

    #controls { position: fixed; bottom: 20px; right: 20px; z-index: 100; display: none; gap: 10px; }
    .ui-btn { border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
    .reset-btn { background: #ef4444; }
    .toggle-btn { background: #14532d; border: 1px solid var(--acc); color: var(--acc); }
    .results-btn { background: var(--gold); color: #020617; display: none; }
    
    #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 200; pointer-events: none; display: none; }
    #countdown { font-size: 15rem; font-weight: 900; color: var(--acc); text-shadow: 0 0 20px rgba(100, 255, 78, 0.5); }
</style>
</head>
<body>

<div id="lobby">
    <a href="https://sawyinator.uk" class="back-home">‚Üê Back to main website</a>
    <div class="lobby-box">
        <h1 style="color:var(--acc)">MARBLE DECIDER</h1>
        <textarea id="nameInput" placeholder="Enter Names">Alpha&#10;Beta&#10;Gamma&#10;Delta&#10;Epsilon&#10;Zeta&#10;Eta&#10;Theta&#10;Iota&#10;Kappa</textarea>
        <div style="display: flex; gap: 10px; flex-direction: column;">
            <button class="start-btn" id="startBtn">START RACE</button>
            <button class="ui-btn toggle-btn" id="shuffleBtn" style="padding: 12px; border-radius: 50px;">SHUFFLE NAMES</button>
        </div>
    </div>
</div>

<div id="results-modal">
    <div class="results-box">
        <h2 style="color:var(--gold); text-align:center; margin-top:0;">üèÜ FINAL STANDINGS üèÜ</h2>
        <div id="full-results-list"></div>
        <button class="start-btn" style="width:100%; margin-top:20px;" id="closeResults">CLOSE</button>
    </div>
</div>

<div id="overlay"><div id="countdown">3</div></div>
<div id="leaderboard">
    <div class="leader-row header-row"><span>Racer</span></div>
    <div id="leader-list"></div>
    
    <div id="recent-victors-container" style="display: none; margin-top: 20px; border-top: 1px solid var(--acc); padding-top: 10px;">
        <div class="leader-row header-row"><span>Recent Victors</span><span style="text-align:right">Time</span></div>
        <div id="recent-victors-list"></div>
    </div>
</div>

<div id="controls">
    <button class="ui-btn results-btn" id="resBtn">FULL RESULTS</button>
    <button class="ui-btn toggle-btn" id="toggleBoard">HIDE/SHOW LEADERBOARDS</button>
    <button class="ui-btn reset-btn" id="reloadBtn">BACK TO LOBBY</button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

let engine, render, runner, marbles = [], finishedMarbles = [], finishLineY = 0;
let camY = 0, autoResultsShown = false, startTime = null;

const createGuides = (world, y, cx) => {
    const wallStyle = { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 2 } };
    Composite.add(world, [
        Bodies.rectangle(cx - 350, y + 100, 300, 60, { ...wallStyle, angle: 0.5 }),
        Bodies.rectangle(cx + 350, y + 100, 300, 60, { ...wallStyle, angle: -0.5 })
    ]);
};

const TrackModules = [
    {
        name: "The Mixer",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            const parts = [];
            for(let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                parts.push(Bodies.rectangle(cx + Math.cos(angle) * 120, y + 500 + Math.sin(angle) * 120, 320, 80, { 
                    angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } 
                }));
            }
            const spinner = Body.create({ parts: parts, isStatic: false, frictionAir: 0 });
            const constraint = Constraint.create({ pointA: { x: cx, y: y + 500 }, bodyB: spinner, stiffness: 1, length: 0 });
            Composite.add(world, [spinner, constraint]);
            Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(spinner, 0.05));
        }
    },
    {
        name: "The Great Tightrope",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
            const splitter = Bodies.polygon(cx, y + 450, 4, 180, { ...wallStyle, angle: Math.PI / 4 });
            Composite.add(world, splitter);
            
            [cx - 300, cx + 300].forEach((xPos, i) => {
                const gate = Bodies.rectangle(xPos, y + 750, 240, 70, { 
                    render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 15 }, frictionAir: 0
                });
                const cons = Constraint.create({ pointA: { x: xPos, y: y + 750 }, bodyB: gate, stiffness: 1, length: 0 });
                Composite.add(world, [gate, cons]);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(gate, i === 0 ? 0.08 : -0.08));
            });
        }
    },
    {
        name: "Centripetal Slingshot",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            [cx - 240, cx + 240].forEach((xPos, i) => {
                const sat = Bodies.rectangle(xPos + (i === 0 ? 100 : -100), y + 500, 280, 80, { 
                    render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 20 }, frictionAir: 0
                });
                const cons = Constraint.create({ pointA: { x: xPos, y: y + 500 }, bodyB: sat, stiffness: 1, length: 0 });
                Composite.add(world, [sat, cons]);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(sat, i === 0 ? 0.18 : -0.18));
            });
        }
    },
    {
        name: "Heavy Pendulum Squeeze",
        create: (world, y, cx) => {
            for(let i = 0; i < 2; i++) {
                const xPos = cx - 200 + (i * 400);
                const weight = Bodies.rectangle(xPos, y + 600, 300, 100, { 
                    render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 }, chamfer: { radius: 30 }, 
                    frictionAir: 0.02, restitution: 0.7, inertia: 7500 
                });
                const pivot = Constraint.create({ 
                    pointA: { x: xPos, y: y + 150 }, bodyB: weight, stiffness: 0.01, length: 400,
                    render: { strokeStyle: '#64ff4e', lineWidth: 4 }
                });
                Composite.add(world, [weight, pivot]);
            }
        }
    },
    {
        name: "Double Cyclone",
        create: (world, y, cx) => {
            [cx - 180, cx + 180].forEach((xPos, idx) => {
                const parts = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    if (i === 0) continue; 
                    parts.push(Bodies.rectangle(
                        xPos + Math.cos(angle) * 140, y + 450 + Math.sin(angle) * 140, 100, 45, 
                        { angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 3 } }
                    ));
                }
                const spinner = Body.create({ parts: parts, isStatic: false, frictionAir: 0 });
                const constraint = Constraint.create({ pointA: { x: xPos, y: y + 450 }, bodyB: spinner, stiffness: 1, length: 0 });
                Composite.add(world, [spinner, constraint]);
                Events.on(engine, 'beforeUpdate', () => Body.setAngularVelocity(spinner, idx === 0 ? 0.1 : -0.1));
            });
        }
    },
    {
        name: "Zig-Zag Plunge",
        create: (world, y, cx) => {
            const stepStyle = { isStatic: true, chamfer: { radius: 40 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 5 } };
            for (let i = 0; i < 5; i++) {
                const isLeft = i % 2 === 0;
                Composite.add(world, Bodies.rectangle(isLeft ? cx - 350 : cx + 350, y + (i * 180), 750, 100, { ...stepStyle, angle: isLeft ? 0.5 : -0.5 }));
            }
        }
    },
    {
        name: "Deep Funnel",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, chamfer: { radius: 30 }, restitution: 0.2, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 8 } };
            Composite.add(world, [
                Bodies.rectangle(cx - 320, y + 250, 550, 110, { ...wallStyle, angle: 0.75 }),
                Bodies.rectangle(cx + 320, y + 250, 550, 110, { ...wallStyle, angle: -0.75 }),
                Bodies.circle(cx, y + 550, 80, { isStatic: true, restitution: 0.3, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } })
            ]);
        }
    },
    {
        name: "Gravity Well",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, chamfer: { radius: 25 }, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 6 } };
            Composite.add(world, [
                Bodies.rectangle(cx - 250, y + 300, 500, 80, { ...wallStyle, angle: 0.8 }),
                Bodies.rectangle(cx + 250, y + 300, 500, 80, { ...wallStyle, angle: -0.8 }),
                Bodies.polygon(cx, y + 650, 3, 70, { isStatic: true, restitution: 0.8, angle: Math.PI, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } })
            ]);
        }
    },
    {
        name: "Bumper Gauntlet",
        create: (world, y, cx) => {
            const bumperStyle = { isStatic: true, restitution: 1.1, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 4 } };
            const positions = [{x: -160, y: 150}, {x: 160, y: 150}, {x: 0, y: 400}, {x: -160, y: 650}, {x: 160, y: 650}];
            positions.forEach(pos => {
                Composite.add(world, Bodies.circle(cx + pos.x, y + pos.y, 55, bumperStyle));
            });
        }
    }
];

window.onload = function() {
    const nameBox = document.getElementById('nameInput');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');

    const saved = localStorage.getItem('marbleRacerNames');
    if (saved) nameBox.value = saved;

    shuffleBtn.onclick = function() {
        const lines = nameBox.value.split('\n').filter(n => n.trim() !== "");
        for (let i = lines.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lines[i], lines[j]] = [lines[j], lines[i]];
        }
        nameBox.value = lines.join('\n');
    };

    startBtn.onclick = function() {
        const names = nameBox.value.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
            localStorage.setItem('marbleRacerNames', nameBox.value);
            initiateRace(names);
        }
    };

    document.getElementById('reloadBtn').onclick = () => location.reload();
    document.getElementById('toggleBoard').onclick = toggleLeaderboard;
    document.getElementById('closeResults').onclick = () => document.getElementById('results-modal').style.display='none';
    document.getElementById('resBtn').onclick = showFullResults;
};

function initiateRace(names) {
    document.getElementById('lobby').style.display = 'none';
    document.getElementById('leaderboard').style.display = 'block';
    document.getElementById('controls').style.display = 'flex';
    setupRace(names);
}

function setupRace(names) {
    // Reset back to original iterations for performance
    engine = Engine.create({ positionIterations: 10, velocityIterations: 10 }); 
    render = Render.create({
        element: document.body, engine: engine,
        options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#010a01' }
    });

    const cx = window.innerWidth / 2;
    const SEG_HEIGHT = 900;
    const trackDepth = 12; 
    let currentY = 400;
    let lastModuleIndex = -1;

    for(let i = 0; i < trackDepth; i++) {
        let randIndex;
        do { randIndex = Math.floor(Math.random() * TrackModules.length); } while (randIndex === lastModuleIndex);
        lastModuleIndex = randIndex;
        TrackModules[randIndex].create(engine.world, currentY, cx);
        currentY += SEG_HEIGHT;
    }

    finishLineY = currentY + 400;
    const wallWidth = 2000;
    const wallStyle = { isStatic: true, friction: 0.1, restitution: 0.3, render: { fillStyle: '#010a01', strokeStyle: '#14532d', lineWidth: 1 } };
    
    Composite.add(engine.world, [
        Bodies.rectangle(cx - 410 - (wallWidth/2), currentY/2 + 2500, wallWidth, currentY + 10000, wallStyle),
        Bodies.rectangle(cx + 410 + (wallWidth/2), currentY/2 + 2500, wallWidth, currentY + 10000, wallStyle)
    ]);

    const checkerCanvas = document.createElement('canvas');
    const checkerCtx = checkerCanvas.getContext('2d');
    checkerCanvas.width = 40; checkerCanvas.height = 40;
    checkerCtx.fillStyle = '#052e16'; checkerCtx.fillRect(0, 0, 40, 40);
    checkerCtx.fillStyle = '#64ff4e'; checkerCtx.fillRect(0, 0, 20, 20); checkerCtx.fillRect(20, 20, 20, 20);
    const finishPattern = checkerCtx.createPattern(checkerCanvas, 'repeat');

    Composite.add(engine.world, [
        Bodies.rectangle(cx, finishLineY, 820, 120, { 
            isStatic: true, isSensor: true, label: 'finish', 
            render: { fillStyle: finishPattern, strokeStyle: '#64ff4e', lineWidth: 6 } 
        })
    ]);

    const gate = Bodies.rectangle(cx, 180, 800, 80, { isStatic: true, render: { fillStyle: '#052e16', strokeStyle: '#64ff4e', lineWidth: 5 } });
    Composite.add(engine.world, gate);

    // GRID SPAWNING (Maintained for overlap prevention)
    const marbleRadius = 20; 
    const padding = 4;
    const cellSize = (marbleRadius * 2) + padding;
    const gateWidth = 780; 
    const marblesPerRow = Math.floor(gateWidth / cellSize);

    marbles = names.map((n, i) => {
    const color = `hsl(${i * (360/names.length)}, 70%, 55%)`;
    const row = Math.floor(i / marblesPerRow);
    const col = i % marblesPerRow;

    // Calculate how many marbles are actually in THIS specific row
    const marblesInThisRow = Math.min(marblesPerRow, names.length - (row * marblesPerRow));
    
    // Calculate the total width this row takes up
    const rowWidth = (marblesInThisRow - 1) * cellSize;
    
    // Center the row by starting at (Center - Half of the row's width)
    const startX = cx - (rowWidth / 2) + (col * cellSize);
    const startY = 150 - (row * cellSize); 

    return Bodies.circle(startX, startY, marbleRadius, { 
        restitution: 0.4, friction: 0.002, frictionAir: 0.005, label: n, 
        render: { fillStyle: color, textColor: color }, isFinished: false, finishTime: null
    });
});
    Composite.add(engine.world, marbles);

    Events.on(engine, 'afterUpdate', () => {
    const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
    
    // 1. Update Live Leaderboard (Top 10 still racing)
    let liveHtml = '';
    active.slice(0, 10).forEach((m, i) => {
        let gapDisplay = '-';
        const marbleBehind = active[i + 1];
        if (marbleBehind) gapDisplay = `+${((m.position.y - marbleBehind.position.y) / 50).toFixed(1)}m`;
        liveHtml += `<div class="leader-row" style="color:${m.render.textColor}"><span>${finishedMarbles.length + i + 1}. ${m.label}</span><span style="text-align:right">${gapDisplay}</span></div>`;
    });
    document.getElementById('leader-list').innerHTML = liveHtml;

    // 2. Update Recent Victors (10 most recent)
    if (finishedMarbles.length > 0) {
        document.getElementById('recent-victors-container').style.display = 'block';
        
        // Get the 10 most recent (last items in finishedMarbles array, reversed)
        const recent = [...finishedMarbles].reverse().slice(0, 10);
        
        let victorsHtml = '';
        recent.forEach((m) => {
            // Find overall rank
            const rank = finishedMarbles.indexOf(m) + 1;
            victorsHtml += `
                <div class="leader-row finished-row" style="color:${m.render.textColor}; font-size: 0.75rem;">
                    <span>#${rank} ${m.label}</span>
                    <span style="text-align:right">${m.finishTime}s</span>
                </div>`;
        });
        document.getElementById('recent-victors-list').innerHTML = victorsHtml;
    }

    if (active.length === 0 && !autoResultsShown && marbles.length > 0) { 
        autoResultsShown = true; 
        showFullResults(); 
    }
});

    Events.on(engine, 'collisionStart', (e) => {
        e.pairs.forEach(p => {
            const marble = p.bodyA.label === 'finish' ? p.bodyB : (p.bodyB.label === 'finish' ? p.bodyA : null);
            if (marble && !marble.isFinished && marble.label && !marble.label.includes('Body')) {
                marble.isFinished = true;
                marble.finishTime = ((performance.now() - startTime) / 1000).toFixed(2);
                finishedMarbles.push(marble);
                document.getElementById('resBtn').style.display = 'block';
                if (finishedMarbles.length === 1) confetti({ particleCount: 150, origin: { y: 0.6 } });
            }
        });
    });

    const overlay = document.getElementById('overlay'), countDisplay = document.getElementById('countdown');
    overlay.style.display = 'flex';
    let count = 3;
    const timer = setInterval(() => {
        count--;
        if(count <= 0) { 
            clearInterval(timer); overlay.style.display = 'none'; 
            Composite.remove(engine.world, gate); startTime = performance.now(); 
        }
        else { countDisplay.innerText = count; }
    }, 1000);

    let lastTime = 0;
    // OPTIMIZED DRAW LOOP (Maintained for framerate)
    function update(time) {
        if (time - lastTime >= (1000/60)) {
            Engine.update(engine, 1000/60);
            const followTargets = marbles.filter(m => !m.isFinished);
            if (followTargets.length > 0) {
                const leadY = Math.max(...followTargets.map(m => m.position.y));
                camY += (leadY - camY - (window.innerHeight / 3)) * 0.1; 
            }
            Render.lookAt(render, { min: { x: cx - window.innerWidth/2, y: camY }, max: { x: cx + window.innerWidth/2, y: camY + window.innerHeight } });
            Render.world(render);
            
            const ctx = render.context;
            ctx.font = 'bold 20px "Segoe UI"'; 
            ctx.textAlign = 'center';

            const minY = render.bounds.min.y - 50;
            const maxY = render.bounds.max.y + 50;

            marbles.forEach(m => {
                if(!m.isFinished && m.position.y > minY && m.position.y < maxY) {
                    const x = m.position.x - render.bounds.min.x;
                    const y = m.position.y - render.bounds.min.y;
                    ctx.fillStyle = m.render.textColor; 
                    ctx.fillText(m.label, x, y - 25);
                }
            });
            lastTime = time;
        }
        requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
}

function toggleLeaderboard() {
    const lb = document.getElementById('leaderboard');
    lb.style.display = lb.style.display === 'none' ? 'block' : 'none';
}

function showFullResults() {
    const list = document.getElementById('full-results-list');
    const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
    const allRanked = [...finishedMarbles, ...active];
    list.innerHTML = allRanked.map((m, i) => `
        <div class="results-item" style="color:${m.render.textColor}"><span>#${i+1} ${m.label}</span><span>${m.isFinished ? m.finishTime + 's' : 'DNF'}</span></div>
    `).join('');
    document.getElementById('results-modal').style.display = 'flex';
}
</script>
</body>
</html>
