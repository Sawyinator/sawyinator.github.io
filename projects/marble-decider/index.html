<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Marble Decider - High Spin Physics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        .back-home {
            position: fixed;
            top: 20px;
            left: 20px;
            text-decoration: none;
            color: var(--acc);
            font-weight: bold;
            background: rgba(15, 23, 42, 0.8);
            padding: 10px 20px;
            border: 1px solid var(--acc);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .back-home:hover {
            background: var(--acc);
            color: #020617;
        }
        :root { --bg: #020617; --ui: #0f172a; --acc: #38bdf8; --gold: #fcd34d; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: white; }
        
        #lobby {
            position: fixed; inset: 0; z-index: 500;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .lobby-box {
            background: var(--ui); padding: 40px; border: 1px solid var(--acc);
            border-radius: 20px; width: 400px; text-align: center;
        }
        textarea {
            width: 100%; height: 200px; background: #020617; color: white;
            border: 1px solid #334155; border-radius: 8px; padding: 10px; margin-bottom: 20px;
        }
        .start-btn {
            background: var(--acc); color: #020617; border: none; padding: 15px 40px;
            font-size: 1.2rem; font-weight: 900; border-radius: 50px; cursor: pointer;
        }

        #leaderboard {
            position: fixed; top: 20px; right: 20px; z-index: 100;
            background: rgba(15, 23, 42, 0.95); padding: 15px; border: 1px solid var(--acc);
            border-radius: 12px; min-width: 280px; max-height: 80vh; overflow-y: auto; 
            backdrop-filter: blur(8px); display: none;
        }
        .leader-row { 
            display: grid; 
            grid-template-columns: 1fr 80px; 
            gap: 10px; 
            margin-bottom: 8px; 
            font-size: 0.85rem; 
            font-weight: bold; 
        }
        .finished-row { border-left: 3px solid var(--gold); background: rgba(252, 211, 77, 0.1); padding-left: 5px; }
        .header-row { font-size: 0.65rem; color: #64748b; border-bottom: 1px solid #334155; }
        
        #results-modal {
            position: fixed; inset: 0; z-index: 600; background: rgba(2, 6, 23, 0.9);
            display: none; align-items: center; justify-content: center; padding: 20px;
        }
        .results-box {
            background: var(--ui); border: 2px solid var(--gold); border-radius: 20px;
            width: 100%; max-width: 500px; max-height: 85vh; overflow-y: auto; padding: 30px;
        }
        .results-item { padding: 10px; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; font-weight: bold; }

        #controls { position: fixed; bottom: 20px; right: 20px; z-index: 100; display: none; gap: 10px; }
        .ui-btn { border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; color: white; }
        .reset-btn { background: #ef4444; }
        .toggle-btn { background: #334155; border: 1px solid var(--acc); }
        .results-btn { background: var(--gold); color: #020617; display: none; }
        
        #overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 200; pointer-events: none; display: none; }
        #countdown { font-size: 15rem; font-weight: 900; color: var(--acc); }
    </style>
</head>
<body>

<div id="lobby">
    <a href="https://sawyinator.uk" class="back-home">‚Üê Back to main website</a>
    
    <div class="lobby-box">
        <h1 style="color:var(--acc)">MARBLE DECIDER</h1>
        <textarea id="nameInput" placeholder="Enter Names">Alpha&#10;Beta&#10;Gamma&#10;Delta&#10;Epsilon&#10;Zeta&#10;Eta&#10;Theta&#10;Iota&#10;Kappa</textarea>
        <div style="display: flex; gap: 10px; flex-direction: column;">
            <button class="start-btn" id="startBtn">START RACE</button>
            <button class="ui-btn toggle-btn" id="shuffleBtn" style="padding: 12px; border-radius: 50px;">SHUFFLE NAMES</button>
        </div>
    </div>
</div>

<div id="results-modal">
    <div class="results-box">
        <h2 style="color:var(--gold); text-align:center; margin-top:0;">üèÜ FINAL STANDINGS üèÜ</h2>
        <div id="full-results-list"></div>
        <button class="start-btn" style="width:100%; margin-top:20px;" id="closeResults">CLOSE</button>
    </div>
</div>

<div id="overlay"><div id="countdown">3</div></div>
<div id="leaderboard">
    <div class="leader-row header-row"><span>Racer</span></div>
    <div id="leader-list"></div>
</div>

<div id="controls">
    <button class="ui-btn results-btn" id="resBtn">FULL RESULTS</button>
    <button class="ui-btn toggle-btn" id="toggleBoard">HIDE/SHOW LEADERBOARD</button>
    <button class="ui-btn reset-btn" id="reloadBtn">BACK TO LOBBY</button>
</div>

<script>
const { Engine, Render, Runner, Bodies, Composite, Events, Constraint, Body } = Matter;

let engine, render, runner, marbles = [], finishedMarbles = [], finishLineY = 0;
let camY = 0, autoResultsShown = false, startTime = null;

window.onload = function() {
    const nameBox = document.getElementById('nameInput');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');

    const saved = localStorage.getItem('marbleRacerNames');
    if (saved) nameBox.value = saved;

    shuffleBtn.onclick = function() {
        const lines = nameBox.value.split('\n').filter(n => n.trim() !== "");
        for (let i = lines.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lines[i], lines[j]] = [lines[j], lines[i]];
        }
        nameBox.value = lines.join('\n');
    };

    startBtn.onclick = function() {
        const val = nameBox.value;
        const names = val.split('\n').map(n => n.trim()).filter(n => n);
        if (names.length > 0) {
            localStorage.setItem('marbleRacerNames', val);
            initiateRace(names);
        }
    };

    document.getElementById('reloadBtn').onclick = () => location.reload();
    document.getElementById('toggleBoard').onclick = toggleLeaderboard;
    document.getElementById('closeResults').onclick = () => document.getElementById('results-modal').style.display='none';
    document.getElementById('resBtn').onclick = showFullResults;
};

const SEG_HEIGHT = 900; 

const createGuides = (world, y, cx) => {
    const wallStyle = { isStatic: true, render: { fillStyle: '#0f172a' } };
    Composite.add(world, [
        Bodies.rectangle(cx - 350, y + 100, 300, 60, { ...wallStyle, angle: 0.5 }),
        Bodies.rectangle(cx + 350, y + 100, 300, 60, { ...wallStyle, angle: -0.5 })
    ]);
};

const TrackModules = [
    {
        name: "The Mixer",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            const parts = [];
            for(let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                parts.push(Bodies.rectangle(cx + Math.cos(angle) * 120, y + 500 + Math.sin(angle) * 120, 320, 80, { 
                    angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#f43f5e', strokeStyle: '#fff', lineWidth: 3 } 
                }));
            }
            const spinner = Body.create({ parts: parts, isStatic: false });
            const constraint = Constraint.create({ pointA: { x: cx, y: y + 500 }, bodyB: spinner, stiffness: 1, length: 0 });
            Composite.add(world, [spinner, constraint]);
            Events.on(engine, 'beforeUpdate', () => Body.rotate(spinner, 0.04));
        }
    },
    {
        name: "The Great Tightrope",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, render: { fillStyle: '#1e293b', strokeStyle: '#fcd34d', lineWidth: 4 } };
            const splitter = Bodies.polygon(cx, y + 450, 4, 180, { ...wallStyle, angle: Math.PI / 4 });
            Composite.add(world, splitter);
            
            [cx - 300, cx + 300].forEach((xPos, i) => {
                const gate = Bodies.rectangle(xPos, y + 750, 240, 70, { 
                    render: { fillStyle: '#fcd34d' }, chamfer: { radius: 15 } 
                });
                const cons = Constraint.create({ pointA: { x: xPos, y: y + 750 }, bodyB: gate, stiffness: 1, length: 0 });
                Composite.add(world, [gate, cons]);
                Events.on(engine, 'beforeUpdate', () => Body.rotate(gate, i === 0 ? 0.08 : -0.08));
            });
        }
    },
    {
        name: "Centripetal Slingshot",
        create: (world, y, cx) => {
            createGuides(world, y, cx);
            [cx - 240, cx + 240].forEach((xPos, i) => {
                const sat = Bodies.rectangle(xPos + (i === 0 ? 100 : -100), y + 500, 280, 80, { 
                    render: { fillStyle: '#a855f7', strokeStyle: '#fff', lineWidth: 2 }, chamfer: { radius: 20 }
                });
                const cons = Constraint.create({ pointA: { x: xPos, y: y + 500 }, bodyB: sat, stiffness: 1, length: 0 });
                Composite.add(world, [sat, cons]);
                Events.on(engine, 'beforeUpdate', () => Body.rotate(sat, i === 0 ? 0.15 : -0.15));
            });
        }
    },
    {
        name: "Heavy Pendulum Squeeze",
        create: (world, y, cx) => {
            for(let i = 0; i < 2; i++) {
                const xPos = cx - 200 + (i * 400);
                const weight = Bodies.rectangle(xPos, y + 600, 300, 100, { 
                    render: { fillStyle: '#10b981' }, chamfer: { radius: 30 }, 
                    frictionAir: 0, // Removed air resistance so it keeps spinning easily
                    restitution: 0.8,
                    inertia: 5000 // Lowered inertia to make it spin more easily when hit on the side
                });
                const pivot = Constraint.create({ 
                    pointA: { x: xPos, y: y + 150 }, 
                    bodyB: weight, 
                    stiffness: 0.01,
                    length: 400,
                    render: { strokeStyle: '#334155', lineWidth: 8 }
                });
                Composite.add(world, [weight, pivot]);
            }
        }
    },
    {
        name: "Double Cyclone",
        create: (world, y, cx) => {
            [cx - 180, cx + 180].forEach((xPos, idx) => {
                const parts = [];
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    if (i === 0) continue; 
                    parts.push(Bodies.rectangle(
                        xPos + Math.cos(angle) * 140, 
                        y + 450 + Math.sin(angle) * 140, 
                        100, 45, 
                        { angle: angle, chamfer: { radius: 20 }, render: { fillStyle: '#a855f7', strokeStyle: '#fff', lineWidth: 2 } }
                    ));
                }
                const spinner = Body.create({ parts: parts, isStatic: false });
                const constraint = Constraint.create({ pointA: { x: xPos, y: y + 450 }, bodyB: spinner, stiffness: 1, length: 0 });
                Composite.add(world, [spinner, constraint]);
                Events.on(engine, 'beforeUpdate', () => Body.rotate(spinner, idx === 0 ? 0.07 : -0.07));
            });
        }
    },
    {
        name: "Zig-Zag Plunge",
        create: (world, y, cx) => {
            const stepStyle = { isStatic: true, chamfer: { radius: 40 }, render: { fillStyle: '#10b981', strokeStyle: '#064e3b', lineWidth: 5 } };
            for (let i = 0; i < 5; i++) {
                const isLeft = i % 2 === 0;
                Composite.add(world, Bodies.rectangle(isLeft ? cx - 350 : cx + 350, y + (i * 180), 750, 100, { ...stepStyle, angle: isLeft ? 0.5 : -0.5 }));
            }
        }
    },
    {
        name: "Deep Funnel",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, chamfer: { radius: 30 }, restitution: 0.2, render: { fillStyle: '#0f172a', strokeStyle: '#fcd34d', lineWidth: 8 } };
            Composite.add(world, [
                Bodies.rectangle(cx - 320, y + 250, 550, 110, { ...wallStyle, angle: 0.75 }),
                Bodies.rectangle(cx + 320, y + 250, 550, 110, { ...wallStyle, angle: -0.75 }),
                Bodies.circle(cx, y + 550, 80, { isStatic: true, restitution: 0.3, render: { fillStyle: '#38bdf8', strokeStyle: '#fff', lineWidth: 2 } })
            ]);
        }
    },
    {
        name: "Gravity Well",
        create: (world, y, cx) => {
            const wallStyle = { isStatic: true, chamfer: { radius: 25 }, render: { fillStyle: '#1e293b', strokeStyle: '#f43f5e', lineWidth: 6 } };
            Composite.add(world, [
                Bodies.rectangle(cx - 250, y + 300, 500, 80, { ...wallStyle, angle: 0.8 }),
                Bodies.rectangle(cx + 250, y + 300, 500, 80, { ...wallStyle, angle: -0.8 }),
                Bodies.polygon(cx, y + 650, 3, 70, { isStatic: true, restitution: 0.8, angle: Math.PI, render: { fillStyle: '#f43f5e' } })
            ]);
        }
    },
    {
        name: "Bumper Gauntlet",
        create: (world, y, cx) => {
            const bumperStyle = { isStatic: true, restitution: 1.1, render: { fillStyle: '#fbbf24', strokeStyle: '#fff', lineWidth: 4 } };
            const positions = [{x: -160, y: 150}, {x: 160, y: 150}, {x: 0, y: 400}, {x: -160, y: 650}, {x: 160, y: 650}];
            positions.forEach(pos => {
                Composite.add(world, Bodies.circle(cx + pos.x, y + pos.y, 55, bumperStyle));
            });
        }
    }
];

function initiateRace(names) {
    document.getElementById('lobby').style.display = 'none';
    document.getElementById('leaderboard').style.display = 'block';
    document.getElementById('controls').style.display = 'flex';
    setupRace(names);
}

function setupRace(names) {
    engine = Engine.create({ positionIterations: 10, velocityIterations: 10 }); 
    render = Render.create({
        element: document.body, engine: engine,
        options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: '#020617' }
    });

    const cx = window.innerWidth / 2;
    const trackDepth = 12; 
    let currentY = 400;
    let lastModuleIndex = -1;

    for(let i = 0; i < trackDepth; i++) {
        let randIndex;
        do {
            randIndex = Math.floor(Math.random() * TrackModules.length);
        } while (randIndex === lastModuleIndex);
        
        lastModuleIndex = randIndex;
        const randModule = TrackModules[randIndex];
        randModule.create(engine.world, currentY, cx);
        currentY += SEG_HEIGHT;
    }

    finishLineY = currentY;
    const wallWidth = 2000;
    const wallStyle = { isStatic: true, friction: 0.1, restitution: 0.3, render: { fillStyle: '#0f172a' } };
    
    Composite.add(engine.world, [
        Bodies.rectangle(cx - 410 - (wallWidth/2), currentY/2, wallWidth, currentY + 5000, wallStyle),
        Bodies.rectangle(cx + 410 + (wallWidth/2), currentY/2, wallWidth, currentY + 5000, wallStyle),
        Bodies.rectangle(cx, finishLineY, 820, 160, { isStatic: true, isSensor: true, label: 'finish', render: { fillStyle: '#facc15' } })
    ]);

    const gate = Bodies.rectangle(cx, 180, 800, 80, { isStatic: true, render: { fillStyle: '#f43f5e' } });
    Composite.add(engine.world, gate);

    marbles = names.map((n, i) => {
        const color = `hsl(${i * (360/names.length)}, 70%, 55%)`;
        return Bodies.circle(cx - 150 + (i*42 % 300), 100, 20, { 
            restitution: 0.4, friction: 0.002, frictionAir: 0.005, label: n, 
            render: { fillStyle: color, textColor: color }, isFinished: false, finishTime: null
        });
    });
    Composite.add(engine.world, marbles);

    Events.on(engine, 'afterUpdate', () => {
        const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
        let html = '';

        finishedMarbles.slice(0, 10).forEach((m, i) => {
            html += `<div class="leader-row finished-row" style="color:${m.render.textColor}">
                        <span>${i + 1}. ${m.label}</span>
                        <span style="text-align:right; font-size: 0.7rem; opacity: 0.8;">FINISH</span>
                     </div>`;
        });

        active.slice(0, 10 - finishedMarbles.length).forEach((m, i) => {
            let gapDisplay = '-';
            const marbleBehind = active[i + 1];
            if (marbleBehind) {
                const gapPixels = m.position.y - marbleBehind.position.y;
                gapDisplay = `+${(gapPixels / 50).toFixed(1)}m`;
            }

            html += `<div class="leader-row" style="color:${m.render.textColor}">
                        <span>${finishedMarbles.length + i + 1}. ${m.label}</span>
                        <span style="text-align:right">${gapDisplay}</span>
                     </div>`;
        });

        document.getElementById('leader-list').innerHTML = html;
        
        if (active.length === 0 && !autoResultsShown && marbles.length > 0) { 
            autoResultsShown = true; 
            showFullResults(); 
        }
    });

    Events.on(engine, 'collisionStart', (e) => {
        e.pairs.forEach(p => {
            const marble = p.bodyA.label === 'finish' ? p.bodyB : (p.bodyB.label === 'finish' ? p.bodyA : null);
            if (marble && !marble.isFinished) {
                marble.isFinished = true;
                marble.finishTime = ((performance.now() - startTime) / 1000).toFixed(2);
                finishedMarbles.push(marble);
                document.getElementById('resBtn').style.display = 'block';
                if (finishedMarbles.length === 1) confetti({ particleCount: 150, origin: { y: 0.6 } });
            }
        });
    });

    const overlay = document.getElementById('overlay'), countDisplay = document.getElementById('countdown');
    overlay.style.display = 'flex';
    let count = 3;
    const timer = setInterval(() => {
        count--;
        if(count <= 0) { 
            clearInterval(timer); 
            overlay.style.display = 'none'; 
            Composite.remove(engine.world, gate); 
            startTime = performance.now(); 
        }
        else { countDisplay.innerText = count; }
    }, 1000);

    let lastTime = 0;
    const fps = 60;
    const physicsDelta = 1000 / fps;

    function update(time) {
        const deltaTime = time - lastTime;
        if (deltaTime >= physicsDelta) {
            Engine.update(engine, physicsDelta);
            
            const followTargets = marbles.filter(m => !m.isFinished);
            if (followTargets.length > 0) {
                const leadY = Math.max(...followTargets.map(m => m.position.y));
                camY += (leadY - camY - (window.innerHeight / 3)) * 0.1; 
            }
            Render.lookAt(render, { 
                min: { x: cx - window.innerWidth/2, y: camY }, 
                max: { x: cx + window.innerWidth/2, y: camY + window.innerHeight } 
            });

            Render.world(render);
            
            const ctx = render.context;
            ctx.font = 'bold 20px "Segoe UI"';
            ctx.textAlign = 'center';
            marbles.forEach(m => {
                if(!m.isFinished) {
                    const x = m.position.x - render.bounds.min.x;
                    const y = m.position.y - render.bounds.min.y;
                    ctx.fillStyle = m.render.textColor;
                    ctx.fillText(m.label, x, y - 35);
                }
            });
            lastTime = time;
        }
        requestAnimationFrame(update);
    }
    requestAnimationFrame(update);
}

function toggleLeaderboard() {
    const lb = document.getElementById('leaderboard');
    lb.style.display = lb.style.display === 'none' ? 'block' : 'none';
}

function showFullResults() {
    const list = document.getElementById('full-results-list');
    const active = marbles.filter(m => !m.isFinished).sort((a, b) => b.position.y - a.position.y);
    const allRanked = [...finishedMarbles, ...active];
    list.innerHTML = allRanked.map((m, i) => `
        <div class="results-item" style="color:${m.render.textColor}">
            <span>#${i+1} ${m.label}</span>
            <span>${m.isFinished ? m.finishTime + 's' : 'DNF'}</span>
        </div>
    `).join('');
    document.getElementById('results-modal').style.display = 'flex';
}
</script>
</body>
</html>
